#!/bin/bash
#
# Bootstrap dotfiles
# Mainly inspired from mathiasbynens/dotfiles and holman/dotfiles

# Set working directory
cd "$(dirname "$0")"

set -e

# Global directories
export DOTFILES="~/.dotfiles"
DOTFILES_DIR=$(pwd)
TARGET_DIR=$HOME
CONFIG_FILE=$DOTFILES_DIR/config
lib=$DOTFILES_DIR/lib

# Get command
args=("$@")

# Declarations
debug=
mute=
force_default=
force_all=
reset_colors=
verbose=

init_bootstrap () {
	# Readying
	echo "bootfiles dotstrap $VERSION"
	echo "$DOTFILES/bootstrap"
	echo ''

	# Import functions
	source $lib/utils
	source $lib/print
	source $lib/ask
	source $lib/dir
	source $lib/file
	source $lib/link
	source $lib/git
	source $lib/npm
	source $lib/brew

	# Pull last changes
	# if ask "Pull last version from GitHub ?" Y true; then
	# 	source $DOTFILES_DIR/bin/git-pup
	# 	success ".gitconfig"
	# else
	# 	skipped ".gitconfig"
	# fi
}

# Print command line usage
echo_usage () {
	. $lib/usage
}

echo_debug () {
	if [ "$debug" = true ]; then
		info "Debug is enabled." " " true
		#info "Symbolic dry run" "Changes are not applied while debugging" true
	fi
}

do_config () {
	if [ ! -f "$CONFIG_FILE" ]; then
		user "What is your nickname ?" " "
		read -e NICK

		user "What is your name ?" " "
		read -e NAME

		user "What is your email ?" " "
		read -e EMAIL

		sed -e "s/AUTHOR_NICK/\"$NICK\"/g" \
			-e "s/AUTHOR_NAME/\"$NAME\"/g" \
			-e "s/AUTHOR_EMAIL/\"$EMAIL\"/g" \
			config.sample > config

		success "Identity saved." "config"
	fi

	source $lib/readconf

	info "Using $USER profile" "$DOTFILES/config"

	echo ''
	do_gitconfig

	# npm
	echo ''
	do_npmconfig
}

do_gitconfig () {
	# Create gitconfig if needed
	local gitconfig_file="git/gitconfig."
	if check_file "$gitconfig_file" Y; then
		if ask "Configure git credentials ?" Y true; then
			gitconfig
		else
			skipped "git"
		fi
	else
		warn ".gitconfig already exists" "~${DOTFILES_DIR#$HOME}/$gitconfig_file"
	fi
}

do_npmconfig () {
	# Create npmrc if needed
	local npmconfig_file=".config/npmrc."
	if check_file "$npmconfig_file" Y; then
		if ask "Configure npm init ?" Y true; then
			npmconfig
		else
			skipped "npm"
		fi
	else
		warn ".npmrc already exists" "~${DOTFILES_DIR#$HOME}/$npmconfig_file"
	fi
}

do_link () {
	if ask "Create symbolic links ?" Y true; then
		# find $DOTFILES -name *.
		dir "" link_dotfiles ${ignore_global[@]} || skipped
		dir "bin" link_files ${ignore_global[@]} || skipped
		success "Stuff linked."
	else
		skipped "symlinks"
	fi
}

undo_link () {
	if ask "Erase symbolic links ?" Y true; then
		dir "" unlink_dotfiles ${ignore_global[@]} || skipped
		dir "bin" unlink_files ${ignore_global[@]} || skipped
		success "Symlinks unchained."
	else
		skipped "symlinks"
	fi
}

do_copy () {
	if ask "Copy directories ?" Y true; then
		# find $DOTFILES -name ".*" -maxdepth 1
		for dir in ${directories[@]}; do
			eval "local ignore_dir=\${ignore_${dir#.}[@]}"
			copy $dir ${ignore_dir[@]} || skipped
		done
		success "Stuff copied."
	else
		skipped "directories"
	fi
}

undo_copy () {
	if ask "Remove directories ?" Y true; then
		for dir in ${directories[@]}; do
			eval "local ignore_dir=\${ignore_${dir#.}[@]}"
			dir "$dir" remove ${ignore_dir[@]} || skipped
		done
		success "Stuff removed."
	else
		skipped "directories"
	fi
}

# OS specific configuration
do_defaults () {
	if ask "Set defaults ?" Y true; then
		((indent_level++))
		local defaults=$DOTFILES_DIR/defaults
		if source_file $defaults; then
			((indent_level--))
			success "Stuff configured."
		else
			((indent_level--))
			warn "Configuration did not fully complete" "[defaults]"
		fi
	else
		skipped "defaults"
	fi
}

# Install deps & utils with homebrew
do_setup () {
	if ask "Set up ?" N true; then
		((indent_level++))
		local setup=$DOTFILES_DIR/setup
		if source_file $setup; then
			((indent_level--))
			success "Stuff installed."
		else
			((indent_level--))
			warn "Dependencies did not fully installed" "[setup]"
		fi
	else
		skipped "setup"
	fi
}

sandbox () {
	if [ ! -d $TARGET_DIR ]; then
		mkdir $TARGET_DIR
	fi

	TARGET_DIR="$TARGET_DIR/sandbox"
	info "$TARGET_DIR" "Using sandbox folder"
}

install () {
	do_config

	# Symbolic links
	echo ''
	do_link

	# Directories
	echo ''
	do_copy

	# Set OS defaults
	echo ''
	info "Using $(uname) specific configuration" " " true

	echo ''
	do_defaults

	# Dependencies
	echo ''
	do_setup
}

uninstall () {
	# Does not undo bundles & defaults

	# Symbolic links
	undo_link

	# Directories
	echo ''
	undo_copy

	end_message="Bootstrap uninstalled things."
}

# Run bootstrap with command
parse_flags () {
	if init_bootstrap; then
		# Parse arguments and unset recognized ones
		for (( i = ${#args[@]} - 1; i >= 0; i-- )); do
			case ${args[i]} in

				-a|--auto)
					force_default=true

					unset args[i] ;;

				-d|--debug)
					debug=true

					unset args[i] ;;

				-f|--force)
					force_all=true

					unset args[i] ;;

				-h|--help)
					echo_usage

					unset args[i] ;;

				-t|--test)
					TARGET_DIR="$TARGET_DIR/sandbox"
					[ ! -d $TARGET_DIR ] && mkdir $TARGET_DIR
					info "$TARGET_DIR" "Using sandbox folder"

					unset args[i] ;;

				-u|--ugly)
					reset_colors=true

					unset args[i] ;;

				-v|--verbose)
					verbose=true

					unset args[i] ;;

				-*)
					fail "${args[i]}" "Unknown option"
					echo_usage

					unset args[i] ;;

			esac
		done

		# Print echo_usage if > 1 argument left
		[ ${#args[@]} -gt 1 ] && echo_usage

		cmd=${args[@]}

		# Start
		bootstrap $cmd

	else
		die "An error occured while preparing bootstrap"
	fi
}

do_gitmodule () { # TOBOBTR
	if ask "Add a git submodule ?" Y true; then
		indent_level=1
		gitmodule
		indent_level=0
	else
		skipped
	fi
}

# Execute command
bootstrap () {
	case $1 in
		'')				install ;;
		'install')		install ;;
		'uninstall')	uninstall ;;
		'link')			do_link ;;
		'copy')			do_copy ;;
		'defaults')		do_defaults ;;
		'setup')		do_setup ;;
		'module')		do_gitmodule ;;
		*)				fail "$1" "Unknown command"; echo_usage ;;
	esac
}

# Init
parse_flags

# End
indent_level=0

[ -n "$end_message" ] || end_message="Things were bootstrapped !"
echo ''
success "$end_message" " "
echo ''

# Does not work
#source_file ~/.bash_profile
